<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Mobile Manipulation: RobotPlacement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mobile Manipulation
   </div>
   <div id="projectbrief">Mobile Manipulation thesis focused on Robot Placement</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classRobotPlacement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RobotPlacement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classRobotPlacement.html" title="The RobotPlacement The main class added for the thesis that computes the best robot placement for the...">RobotPlacement</a> The main class added for the thesis that computes the best robot placement for the given scene.  
 <a href="classRobotPlacement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mm__robot__placement_8h_source.html">mm_robot_placement.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRobotPlacement_1_1CommutationConfiguration.html">CommutationConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main struct describing the commutation configuration ie the robot placement.  <a href="structRobotPlacement_1_1CommutationConfiguration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a44e7c735802f52dd1d4cfac694a0af2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44e7c735802f52dd1d4cfac694a0af2a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a44e7c735802f52dd1d4cfac694a0af2a">InverseMapType</a> { <b>REACHABILITY</b>, 
<b>PLANABILITY</b>, 
<b>FUSION</b>
 }<tr class="memdesc:a44e7c735802f52dd1d4cfac694a0af2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverseMapType enum for the kinds of inverse quality maps that can be used. <br /></td></tr>
</td></tr>
<tr class="separator:a44e7c735802f52dd1d4cfac694a0af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab83b43d0b05d5ea58affe8250f09fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afab83b43d0b05d5ea58affe8250f09fe"></a>
typedef std::multimap&lt; double, std::vector&lt; double &gt;, std::greater&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a></td></tr>
<tr class="memdesc:afab83b43d0b05d5ea58affe8250f09fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">SortedQualityMap This sorts the inverse spheres in decreasing order of their quality value. <br /></td></tr>
<tr class="separator:afab83b43d0b05d5ea58affe8250f09fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e33c97a8848d00fc324e964f1bb18c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a7e33c97a8848d00fc324e964f1bb18c5">RobotPlacement</a> (std::string whole_robot_name, std::string patform_name, std::string arm_name)</td></tr>
<tr class="memdesc:a7e33c97a8848d00fc324e964f1bb18c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRobotPlacement.html" title="The RobotPlacement The main class added for the thesis that computes the best robot placement for the...">RobotPlacement</a> Constructs the base_placement object using the moveit names of the whole robot, mobile platform, and manipulator.  <a href="#a7e33c97a8848d00fc324e964f1bb18c5">More...</a><br /></td></tr>
<tr class="separator:a7e33c97a8848d00fc324e964f1bb18c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493910c0108f4a36164613537cc4b986"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a493910c0108f4a36164613537cc4b986">loadInverseMap</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_map, <a class="el" href="classRobotPlacement.html#a44e7c735802f52dd1d4cfac694a0af2a">InverseMapType</a> map_type)</td></tr>
<tr class="memdesc:a493910c0108f4a36164613537cc4b986"><td class="mdescLeft">&#160;</td><td class="mdescRight">loadInverseMap loads the chosen inverse map from file  <a href="#a493910c0108f4a36164613537cc4b986">More...</a><br /></td></tr>
<tr class="separator:a493910c0108f4a36164613537cc4b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13824e50b9b066840d9674fa1d427017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRobotPlacement_1_1CommutationConfiguration.html">CommutationConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a13824e50b9b066840d9674fa1d427017">determineCommutationConfiguration</a> (geometry_msgs::Pose &amp;target, geometry_msgs::Pose2D &amp;current_base_pose, planning_scene::PlanningScenePtr &amp;scene, nav_msgs::OccupancyGrid &amp;occupancy_map, <a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_spheres)</td></tr>
<tr class="memdesc:a13824e50b9b066840d9674fa1d427017"><td class="mdescLeft">&#160;</td><td class="mdescRight">determineCommutationConfiguration Main function that is called to determine the commutation configuration  <a href="#a13824e50b9b066840d9674fa1d427017">More...</a><br /></td></tr>
<tr class="separator:a13824e50b9b066840d9674fa1d427017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4c3b78600d3a4fd082dcf6b98ed92b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structRobotPlacement_1_1CommutationConfiguration.html">CommutationConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#afc4c3b78600d3a4fd082dcf6b98ed92b">refineCommutationConfiguration</a> (geometry_msgs::Pose &amp;target, geometry_msgs::Pose2D &amp;current_base_pose, planning_scene::PlanningScenePtr &amp;scene, nav_msgs::OccupancyGrid &amp;occupancy_map, <a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> remaining_solutions)</td></tr>
<tr class="memdesc:afc4c3b78600d3a4fd082dcf6b98ed92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">refineCommutationConfiguration When the robot is not able to reach the target pose due to some reason, a new base placment may be carried out using this function  <a href="#afc4c3b78600d3a4fd082dcf6b98ed92b">More...</a><br /></td></tr>
<tr class="separator:afc4c3b78600d3a4fd082dcf6b98ed92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8fbabdaefd6ed77cbdc4a0749313827f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a8fbabdaefd6ed77cbdc4a0749313827f">loadInverseReachabilityMap</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_reach_map)</td></tr>
<tr class="memdesc:a8fbabdaefd6ed77cbdc4a0749313827f"><td class="mdescLeft">&#160;</td><td class="mdescRight">loadInverseReachabilityMap Load the inverse reachability map  <a href="#a8fbabdaefd6ed77cbdc4a0749313827f">More...</a><br /></td></tr>
<tr class="separator:a8fbabdaefd6ed77cbdc4a0749313827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb17d29db96b10a5dbef6fc36c3e7e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#aecb17d29db96b10a5dbef6fc36c3e7e0">loadInversePlanabilityMap</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_plan_map)</td></tr>
<tr class="memdesc:aecb17d29db96b10a5dbef6fc36c3e7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">loadInversePlanabilityMap Load the inverse planability map  <a href="#aecb17d29db96b10a5dbef6fc36c3e7e0">More...</a><br /></td></tr>
<tr class="separator:aecb17d29db96b10a5dbef6fc36c3e7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29033472cbe556bb749ae111911d2d64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a29033472cbe556bb749ae111911d2d64">fuseMap</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_fusion_map)</td></tr>
<tr class="memdesc:a29033472cbe556bb749ae111911d2d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">fuseMap Fuse the inverse reachability and inverse planability maps into single inverse fusion map  <a href="#a29033472cbe556bb749ae111911d2d64">More...</a><br /></td></tr>
<tr class="separator:a29033472cbe556bb749ae111911d2d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038f3e12faaad8dd43223e29ecbfa1c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a038f3e12faaad8dd43223e29ecbfa1c8">transformMapAtPose</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_map, geometry_msgs::Pose &amp;target, <a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_map_tf)</td></tr>
<tr class="memdesc:a038f3e12faaad8dd43223e29ecbfa1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">transformMapAtPose Transform the inverse map at from origin to the chosen target pose  <a href="#a038f3e12faaad8dd43223e29ecbfa1c8">More...</a><br /></td></tr>
<tr class="separator:a038f3e12faaad8dd43223e29ecbfa1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510f9bc1290ca263bb86bb0e74b8a45d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a510f9bc1290ca263bb86bb0e74b8a45d">getArmHeight</a> (std::string arm_link0_name, planning_scene::PlanningScenePtr &amp;scene, double &amp;arm_height)</td></tr>
<tr class="memdesc:a510f9bc1290ca263bb86bb0e74b8a45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">getArmHeight Determine the height at which the inverse map must be sliced to limit the search to feasible arm locations  <a href="#a510f9bc1290ca263bb86bb0e74b8a45d">More...</a><br /></td></tr>
<tr class="separator:a510f9bc1290ca263bb86bb0e74b8a45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77616fa8b0ce0edfc48d83d8d7656cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a77616fa8b0ce0edfc48d83d8d7656cba">sliceMapAtArmHeight</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_map, double &amp;height, double &amp;threshold, <a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_map_sliced)</td></tr>
<tr class="memdesc:a77616fa8b0ce0edfc48d83d8d7656cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">sliceMapAtArmHeight Slice the 3D map based on the height +/- threshold  <a href="#a77616fa8b0ce0edfc48d83d8d7656cba">More...</a><br /></td></tr>
<tr class="separator:a77616fa8b0ce0edfc48d83d8d7656cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c356eeb88dfe05b2ad7ceba9b73c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#ac2c356eeb88dfe05b2ad7ceba9b73c3a">filter2DMap</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;inverse_map_2D, nav_msgs::OccupancyGrid &amp;occupancy_map, <a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;commutations_filtered)</td></tr>
<tr class="memdesc:ac2c356eeb88dfe05b2ad7ceba9b73c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">filter2DMap Filter the feasible commutation configurations based on 2D costmap  <a href="#ac2c356eeb88dfe05b2ad7ceba9b73c3a">More...</a><br /></td></tr>
<tr class="separator:ac2c356eeb88dfe05b2ad7ceba9b73c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fd6d102aa47f71184786b857fc9fe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a17fd6d102aa47f71184786b857fc9fe4">coordToMapCell</a> (double cx, double cy, unsigned int &amp;mx, unsigned int &amp;my, nav_msgs::OccupancyGrid &amp;occupancy_map)</td></tr>
<tr class="memdesc:a17fd6d102aa47f71184786b857fc9fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">coordToMapCell Convert Map coordinate to cell coordinate as in costmap_2d  <a href="#a17fd6d102aa47f71184786b857fc9fe4">More...</a><br /></td></tr>
<tr class="separator:a17fd6d102aa47f71184786b857fc9fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99c0274a7abf462be7efa17f90aa679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#ac99c0274a7abf462be7efa17f90aa679">generateTestStateConfiguration</a> (tf::Vector3 &amp;arm_location, double angle, Eigen::Affine3d &amp;link0_to_base_tf, std::vector&lt; double &gt; &amp;joint_config)</td></tr>
<tr class="memdesc:ac99c0274a7abf462be7efa17f90aa679"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateTestStateConfiguration Generates a robot state at for given arm location when the robot has an angle to arm's base.  <a href="#ac99c0274a7abf462be7efa17f90aa679">More...</a><br /></td></tr>
<tr class="separator:ac99c0274a7abf462be7efa17f90aa679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8ffa8e7b193fac102cd560e45214ea"><td class="memItemLeft" align="right" valign="top">geometry_msgs::Pose2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a3a8ffa8e7b193fac102cd560e45214ea">optimizeBasePose</a> (void)</td></tr>
<tr class="memdesc:a3a8ffa8e7b193fac102cd560e45214ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimizeBasePose Optimize the yaw angle for the base about the chosen arm location  <a href="#a3a8ffa8e7b193fac102cd560e45214ea">More...</a><br /></td></tr>
<tr class="separator:a3a8ffa8e7b193fac102cd560e45214ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd91eb0d9a73fbca4b697c8726a3e17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#aadd91eb0d9a73fbca4b697c8726a3e17">setCommutationColor</a> (double quality, rviz_visual_tools::colors &amp;color)</td></tr>
<tr class="memdesc:aadd91eb0d9a73fbca4b697c8726a3e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">setCommutationColor Sets the color of the sphere to be sent for visualization in rviz  <a href="#aadd91eb0d9a73fbca4b697c8726a3e17">More...</a><br /></td></tr>
<tr class="separator:aadd91eb0d9a73fbca4b697c8726a3e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f1a75f4d185e4485368784a25dad9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a49f1a75f4d185e4485368784a25dad9b">visualizeCommutations</a> (<a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;quality_map, moveit_visual_tools::MoveItVisualToolsPtr viz)</td></tr>
<tr class="memdesc:a49f1a75f4d185e4485368784a25dad9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">visualizeCommutations To trigger visualize a set of inverse quality map in rviz  <a href="#a49f1a75f4d185e4485368784a25dad9b">More...</a><br /></td></tr>
<tr class="separator:a49f1a75f4d185e4485368784a25dad9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af8446a8db524f4b730d6947a8e3668a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8446a8db524f4b730d6947a8e3668a0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#af8446a8db524f4b730d6947a8e3668a0">inverse_reach_map_path_</a></td></tr>
<tr class="memdesc:af8446a8db524f4b730d6947a8e3668a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse_reach_map_path_ The path to the inverse reachability map file <br /></td></tr>
<tr class="separator:af8446a8db524f4b730d6947a8e3668a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc26a29c8c05006b7eb5c0766440d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bcc26a29c8c05006b7eb5c0766440d5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a0bcc26a29c8c05006b7eb5c0766440d5">inverse_plan_map_path_</a></td></tr>
<tr class="memdesc:a0bcc26a29c8c05006b7eb5c0766440d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse_plan_map_path_ The path to the inverse planability map file <br /></td></tr>
<tr class="separator:a0bcc26a29c8c05006b7eb5c0766440d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e62bd242a9edf72dfabea5cf710b2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69e62bd242a9edf72dfabea5cf710b2b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a69e62bd242a9edf72dfabea5cf710b2b">inverse_plan_map_data_path_</a></td></tr>
<tr class="memdesc:a69e62bd242a9edf72dfabea5cf710b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse_plan_map_data_path_ The path to the auxillary iverse planability map file that contains its data <br /></td></tr>
<tr class="separator:a69e62bd242a9edf72dfabea5cf710b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ff9730468d7f12fa9dce7429456ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53ff9730468d7f12fa9dce7429456ba7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a53ff9730468d7f12fa9dce7429456ba7">slice_threshold_</a></td></tr>
<tr class="memdesc:a53ff9730468d7f12fa9dce7429456ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">slice_threshold_ The threshold to be used while slicing the 3D inverse quality map into 2D <br /></td></tr>
<tr class="separator:a53ff9730468d7f12fa9dce7429456ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd3c6a3ec16cf9c6c10d8153bd013f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cd3c6a3ec16cf9c6c10d8153bd013f2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#a4cd3c6a3ec16cf9c6c10d8153bd013f2">whole_robot_group_</a></td></tr>
<tr class="memdesc:a4cd3c6a3ec16cf9c6c10d8153bd013f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">whole_robot_group_ The name of the moveit group describing the whole robot <br /></td></tr>
<tr class="separator:a4cd3c6a3ec16cf9c6c10d8153bd013f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacfb789e277f8d1f8afdeebef128d22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afacfb789e277f8d1f8afdeebef128d22"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#afacfb789e277f8d1f8afdeebef128d22">platform_group_</a></td></tr>
<tr class="memdesc:afacfb789e277f8d1f8afdeebef128d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">platform_group_ The name of the moveit group describing the mobile platform <br /></td></tr>
<tr class="separator:afacfb789e277f8d1f8afdeebef128d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97abd16085bad4cf70187dfb7d95ce9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af97abd16085bad4cf70187dfb7d95ce9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRobotPlacement.html#af97abd16085bad4cf70187dfb7d95ce9">arm_group_</a></td></tr>
<tr class="memdesc:af97abd16085bad4cf70187dfb7d95ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">arm_group_ The name of the moveit group describing the kinematic arm <br /></td></tr>
<tr class="separator:af97abd16085bad4cf70187dfb7d95ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classRobotPlacement.html" title="The RobotPlacement The main class added for the thesis that computes the best robot placement for the...">RobotPlacement</a> The main class added for the thesis that computes the best robot placement for the given scene. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e33c97a8848d00fc324e964f1bb18c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RobotPlacement::RobotPlacement </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>whole_robot_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>platform_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>arm_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classRobotPlacement.html" title="The RobotPlacement The main class added for the thesis that computes the best robot placement for the...">RobotPlacement</a> Constructs the base_placement object using the moveit names of the whole robot, mobile platform, and manipulator. </p>
<p>Used to set the group name variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whole_robot_name</td><td>Name of the robot group as used with moveit </td></tr>
    <tr><td class="paramname">patform_name</td><td>Name of the mobile platform group as used with moveit </td></tr>
    <tr><td class="paramname">arm_name</td><td>Name of the manipulator group as used in moveit</td></tr>
  </table>
  </dd>
</dl>
<p>This program computes the base placement integrated with the moveit planning scene and the 2d cost map</p><ul>
<li>Inputs: criterion, planning scene, robot model, end effector target pose</li>
<li>Outputs: commutation configuration</li>
</ul>
<p>The IR/IP map location would loaded here based on the parameter in the base_placement config file Procedure:</p><ul>
<li>The inverse map is loaded</li>
<li>It is transformed based on the target pose</li>
<li>The map is sliced at the height of the arm</li>
<li>The highest quality position is selected</li>
<li>The position is checked against the 2D map</li>
<li>Then the arm configuration at the target pose is calculated</li>
<li>It is checked against collision</li>
<li>If collision free then the base pose is optimized</li>
<li>Accordingly the arm configuration (the zeroth joint) is updated </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a17fd6d102aa47f71184786b857fc9fe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotPlacement::coordToMapCell </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nav_msgs::OccupancyGrid &amp;&#160;</td>
          <td class="paramname"><em>occupancy_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>coordToMapCell Convert Map coordinate to cell coordinate as in costmap_2d </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>The x coordinate </td></tr>
    <tr><td class="paramname">cy</td><td>The y coordinate </td></tr>
    <tr><td class="paramname">mx</td><td>The number of cells in x </td></tr>
    <tr><td class="paramname">my</td><td>The number of cells in y </td></tr>
    <tr><td class="paramname">occupancy_map</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the map coordinate was valid and could be converted to cell coordinate </dd></dl>

</div>
</div>
<a class="anchor" id="a13824e50b9b066840d9674fa1d427017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRobotPlacement_1_1CommutationConfiguration.html">RobotPlacement::CommutationConfiguration</a> RobotPlacement::determineCommutationConfiguration </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">geometry_msgs::Pose2D &amp;&#160;</td>
          <td class="paramname"><em>current_base_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">planning_scene::PlanningScenePtr &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nav_msgs::OccupancyGrid &amp;&#160;</td>
          <td class="paramname"><em>occupancy_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_spheres</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determineCommutationConfiguration Main function that is called to determine the commutation configuration </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pose msg describing the target pose </td></tr>
    <tr><td class="paramname">current_base_pose</td><td>The current pose2D of the mobile base </td></tr>
    <tr><td class="paramname">scene</td><td>The Planning Scene for MoveIt! </td></tr>
    <tr><td class="paramname">occupancy_map</td><td>The 2D occupancy grid of the robot </td></tr>
    <tr><td class="paramname">inverse_spheres</td><td>The main input of the inverted reachability/planability/fusion quality map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Commutation Configuration ie the pose of the robot at which it must switch from locomotion to manipulation </dd></dl>

</div>
</div>
<a class="anchor" id="ac2c356eeb88dfe05b2ad7ceba9b73c3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotPlacement::filter2DMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_map_2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nav_msgs::OccupancyGrid &amp;&#160;</td>
          <td class="paramname"><em>occupancy_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>commutations_filtered</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>filter2DMap Filter the feasible commutation configurations based on 2D costmap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse_map_2D</td><td>Input sliced 2D map for filtering </td></tr>
    <tr><td class="paramname">occupancy_map</td><td>2D occupancy grid of the scene used to filter feasible positions </td></tr>
    <tr><td class="paramname">commutations_filtered</td><td>The output 2D set of feasible commutation configurations </td></tr>
  </table>
  </dd>
</dl>
<p>Filter those that have cost &gt; 0 </p>

</div>
</div>
<a class="anchor" id="a29033472cbe556bb749ae111911d2d64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotPlacement::fuseMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_fusion_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fuseMap Fuse the inverse reachability and inverse planability maps into single inverse fusion map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse_fusion_map</td><td>The computed inverse fusion map is stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if fusion is successful else false </dd></dl>

</div>
</div>
<a class="anchor" id="ac99c0274a7abf462be7efa17f90aa679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotPlacement::generateTestStateConfiguration </td>
          <td>(</td>
          <td class="paramtype">tf::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>arm_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Affine3d &amp;&#160;</td>
          <td class="paramname"><em>link0_to_base_tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generateTestStateConfiguration Generates a robot state at for given arm location when the robot has an angle to arm's base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arm_location</td><td>The x,y,z vector describing the test arm position around the target </td></tr>
    <tr><td class="paramname">angle</td><td>The yaw of the zeroth link of arm (generally equals 0) </td></tr>
    <tr><td class="paramname">link0_to_base_tf</td><td>The transformation from the link0 of the arm to base_link </td></tr>
    <tr><td class="paramname">joint_config</td><td>The output joint config at the test location for the arm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a510f9bc1290ca263bb86bb0e74b8a45d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotPlacement::getArmHeight </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>arm_link0_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">planning_scene::PlanningScenePtr &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>arm_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getArmHeight Determine the height at which the inverse map must be sliced to limit the search to feasible arm locations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arm_link0_name</td><td>The name of the zeroth link of the arm in moveit urdf </td></tr>
    <tr><td class="paramname">scene</td><td>The planning scene used to compute the output height </td></tr>
    <tr><td class="paramname">arm_height</td><td>The output computed height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a493910c0108f4a36164613537cc4b986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotPlacement::loadInverseMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#a44e7c735802f52dd1d4cfac694a0af2a">InverseMapType</a>&#160;</td>
          <td class="paramname"><em>map_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>loadInverseMap loads the chosen inverse map from file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse_map</td><td>is the variable in which the map is loaded </td></tr>
    <tr><td class="paramname">map_type</td><td>- reachability, planability or combined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the map is loaded successfully else false </dd></dl>

</div>
</div>
<a class="anchor" id="aecb17d29db96b10a5dbef6fc36c3e7e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotPlacement::loadInversePlanabilityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_plan_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loadInversePlanabilityMap Load the inverse planability map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse_plan_map</td><td>The inverse planability map as specified by inverse_plan_map_path_ is stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the map is successfully loaded else false </dd></dl>

</div>
</div>
<a class="anchor" id="a8fbabdaefd6ed77cbdc4a0749313827f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RobotPlacement::loadInverseReachabilityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_reach_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loadInverseReachabilityMap Load the inverse reachability map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse_reach_map</td><td>The inverse reachability map as specified by inverse_reach_map_path_ is stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the map is successfully loaded else false </dd></dl>

</div>
</div>
<a class="anchor" id="a3a8ffa8e7b193fac102cd560e45214ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Pose2D RobotPlacement::optimizeBasePose </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>optimizeBasePose Optimize the yaw angle for the base about the chosen arm location </p>
<dl class="section return"><dt>Returns</dt><dd>Optimized Pose2D for the base </dd></dl>

</div>
</div>
<a class="anchor" id="afc4c3b78600d3a4fd082dcf6b98ed92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRobotPlacement_1_1CommutationConfiguration.html">CommutationConfiguration</a> RobotPlacement::refineCommutationConfiguration </td>
          <td>(</td>
          <td class="paramtype">geometry_msgs::Pose &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">geometry_msgs::Pose2D &amp;&#160;</td>
          <td class="paramname"><em>current_base_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">planning_scene::PlanningScenePtr &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nav_msgs::OccupancyGrid &amp;&#160;</td>
          <td class="paramname"><em>occupancy_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a>&#160;</td>
          <td class="paramname"><em>remaining_solutions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>refineCommutationConfiguration When the robot is not able to reach the target pose due to some reason, a new base placment may be carried out using this function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Pose msg describing the target pose </td></tr>
    <tr><td class="paramname">current_base_pose</td><td>The current pose2D of the mobile base </td></tr>
    <tr><td class="paramname">scene</td><td>The Planning Scene for MoveIt! </td></tr>
    <tr><td class="paramname">occupancy_map</td><td>The 2D occupancy grid of the robot </td></tr>
    <tr><td class="paramname">remaining_solutions</td><td>The remaining untested spheres/positions from the quality map used for determining the commutation configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Commutation Configuratino ie the pose of the robot at which it must switch from locomotion to manipulation </dd></dl>

</div>
</div>
<a class="anchor" id="aadd91eb0d9a73fbca4b697c8726a3e17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotPlacement::setCommutationColor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rviz_visual_tools::colors &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>setCommutationColor Sets the color of the sphere to be sent for visualization in rviz </p>
<p>The colors are divided into 5 categories from RED (lowest quality) to PURPLE (best quality)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quality</td><td>The quality value of the sphere that is used to determine its color </td></tr>
    <tr><td class="paramname">color</td><td>Color with which the sphere will be visualized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77616fa8b0ce0edfc48d83d8d7656cba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotPlacement::sliceMapAtArmHeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_map_sliced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sliceMapAtArmHeight Slice the 3D map based on the height +/- threshold </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse_map</td><td>Input 3D inverse quality map </td></tr>
    <tr><td class="paramname">height</td><td>The height at which the map must be sliced </td></tr>
    <tr><td class="paramname">threshold</td><td>The tolerance around the slicing height which is used to find the spheres within the sliced layer </td></tr>
    <tr><td class="paramname">inverse_map_sliced</td><td>The output sliced Inverse Quality Map in 2D </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a038f3e12faaad8dd43223e29ecbfa1c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotPlacement::transformMapAtPose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">geometry_msgs::Pose &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>inverse_map_tf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>transformMapAtPose Transform the inverse map at from origin to the chosen target pose </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse_map</td><td>Original inverse map </td></tr>
    <tr><td class="paramname">target</td><td>Pose at which the inverse Quality map is to be transformed to </td></tr>
    <tr><td class="paramname">inverse_map_tf</td><td>Transformed inverse map </td></tr>
  </table>
  </dd>
</dl>
<p>@todo point transformation of map (currently pose) </p>

</div>
</div>
<a class="anchor" id="a49f1a75f4d185e4485368784a25dad9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RobotPlacement::visualizeCommutations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRobotPlacement.html#afab83b43d0b05d5ea58affe8250f09fe">SortedQualityMap</a> &amp;&#160;</td>
          <td class="paramname"><em>quality_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">moveit_visual_tools::MoveItVisualToolsPtr&#160;</td>
          <td class="paramname"><em>viz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>visualizeCommutations To trigger visualize a set of inverse quality map in rviz </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quality_map</td><td>The map to visualized </td></tr>
    <tr><td class="paramname">viz</td><td>Pointer to the MoveIt! Visual tools</td></tr>
  </table>
  </dd>
</dl>
<p>Iterate over all spheres in the inverse map and add rviz spheres at their centers with colors based on their quality value </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mobile_manip/<a class="el" href="mm__robot__placement_8h_source.html">mm_robot_placement.h</a></li>
<li>src/mm_robot_placement.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
